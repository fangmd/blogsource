---
title: java -- day7 
date: 2015-12-28 21:18:12
tags: [java,day]
categories: java基础

---

# Day7
## Object 类
>java语言的根类,所有类直接或间接继承object

object中常用的方法:

1. boolean equals(Object obj) :用来比较两个对象是否相同.(若子类不重写,默认比较的是地址值是否相同？？)
2. Class<?> getClass(): 返回一个运行在jvm中相应类的字节码文件的对象.(<?>泛型;Class:表示正运行在jvm中的字节码文件的抽取和封装;Class:为反射而设计的类)
3. int hashCode():返回一个对象在堆中的首地址值(哈希码),不是真是的物理地址值,真实的物理地址值以哈希吗值为参考,根据底层算法,计算出来的.
4. String toString() : 返回一个对象的字符串表现形式,打印一个对象时,会打印:该对象调用toString()方法后的返回值.
## 对象转型
多态:多种状态,指父类的引用可以指向子类对象（还有接口）.`Pet pet = new PetDog()` pet有两种状态:Pet 和PetDog
### 对象的多态
多态的实际应用:在设计的时候,方法的形参类型或者是返回值类型可以使用父类类型,好处是:可以接受父类的任意子对象;提高代码的复用性,减少方法的个数;
### 对象的向上转型
子类对象赋值给父类类型的引用时，会自动将子类对象对应的类型提升为父类类型。

语法：父类类型 引用 = new 子类构造方法（）；

特点：此时，该引用只能调用父类中所有可见的属性和方法，不能调用子类特有的属性和方法。.
### 对象的向下转型
对象的向下转型：将父类对象强制转换为子类类型的过程。

语法：子类类型 引用 =  (子类类型)父类对象的引用;

特点：

1. 此时，该引用可以调用子类特有的方法，同时还可以调用从父类中继承过来的所有方法。
2. 在进行强制类型转换之前，一定要使用instanceof关键字判断一下，否则，很容易抛出“ClassCastException”(类型强制转换的异常)。
      
 instanceof语法：
对象 instanceof 类型
结果：boolean
true:之前的对象是属于之后类型的实例
false：之前的对象不是之后类型的实例
## 抽象类和抽象方法
抽象类:从语法角度说,使用abstract修饰的类称为抽象类

语法:访问权限修饰符 abstract class 类名{//普通属性 //普通方法 //抽象方法}

抽象方法:使用abstract修饰的方法,且没有方法体.

抽象类的特点:

1. 若一个类声明为抽象类,那么该类中可以书写抽象方法也可以不书写抽象方法.
2. 抽象类不能实例化.
3. 普通子类继承抽象父类,那么,该普通对象必须实现父类中所有的抽象方法
4. 若一个抽象的子类继承抽象父类,那么,该抽象子类可以重写抽象父类中所有或者部分抽象方法,也可以不用重写
5. 若一个普通子类继承一个抽象子类,该子类又继承一个抽象父类,那么该普通子类必须重写抽象父类中所有的抽象方法,(即包括抽象子类自己的抽象方法,还包括抽象子类继承过来的抽象方法;但是抽象子类已经重写的方法除外.)
6. 抽象类是为继承而生的;抽象父类中的构造方法,是用来被子类构造方法的第一条语句用过super(XXX)的形式调用的.

抽象类的本质:

若一个类中,某个方法书写方法体没有意义的,一定会被子类重写,那么这个方法就被设计为抽象方法,与之对应的类就升级为抽象类.
## final关键字
final关键字的用法：

①修饰属性或者修饰局部变量（最终变量）
  修饰属性：全局常量。（注意：此时，必须要赋予初始值，否则编译报错）
  修饰局部变量：局部常量。（此时：声明和赋予初始值可以分开）

②修饰方法
  该方法为最终方法，且只能被子类继承，但是不能被子类重写。

③修饰类
  该类就转变为最终类，没有子类的类。（类比：没有孩子，是一个孤寡老人类）
 api中设计好的最终类列举：String,Integer,Math等等。
## 接口
>是一个特殊的抽象类,特殊在接口中所有的属性都是常量,所有的方法都是抽象的方法;

语法:访问权限修饰符 interface 接口名{//全局常量(默认修饰符:public static fianl) //抽象方法(默认修饰符public abstract)}

多态的定义完善:父类或者是接口的引用指向子类或者是实现类的对象.

接口的特点:
1. 接口不能实例化(原因:接口中有抽象方法,若实例化,实例调用该方法时没有意义)
2. 接口是用来被实现类实现的


### 如何实现接口
### 实现接口
### 接口的声明语法
语法:访问权限修饰符 [其他修饰符] class 类名 implements 接口名{ //实现接口中的抽象方法}

①若普通的类实现了接口，那么，该普通类必须得实现接口中所有的抽象方法。

   ②若抽象的类实现了接口，那么，该抽象类可以实现也可以不实现接口中的抽象方法。
     原因：抽象类中可以书写抽象方法的。
     
   ③若一个普通的子类继承了抽象的父类，该抽象的父类又实现了接口，那么，该普通的子类
     必须得重写抽象的父类中所有的抽象方法，以及抽象父类尚未实现的接口中所有的抽象方法。
     
   ④一个普通的子类，可以继承一个父类，同时，可以实现多个接口。
   语法：访问权限修饰符 [修饰符] class 类名 extends 父类名 implements 接口名1，接口名2，。。。{
            //实现类相应的属性和方法
         }
### 接口的使用规则
3、接口可以继承继承接口，而且，一个接口可以有多个父接口。
  原因：可以多继承，继承过来后，即使多个父接口中有同名的抽象方法，也不会造成影响，因为都是抽象方法，
        最终执行的都是实现类中相应的方法。
### 接口的用途
接口的本质：
  从接口设计者的角度而言，接口中定义了一套规范和标准。
  
  接口语法的设计，模拟的是现实世界工业品的生产环节中相应的标准，以及所有的厂商生产的产品都必须遵循标准的约束。
### 接口和抽象类的区别

注意：接口不是实物，是以纸质或者是别的存储介质保存的一套协议、规范、标准等等。
  

--》接口在项目中的使用：
在项目中，将什么设计为类、接口？
根据类、接口的定义来。 
将“功能的扩展”设计为接口。含义：哪个类需要进行功能的扩展，哪个类实现接口即可。

接口还有一种使用方式：模块化的编程（搭积木式的编程）。<---- 大型项目会使用到。

1. 类实现接口
2. 模块化编程

接口和抽象类的异同点：

同：①都不能实例化
    ②接口和抽象类中都可以拥有抽象方法

异：①是否能多继承：抽象类属于类，只能单继承；接口可以多继承

    ②适用场景不同：抽象类---》共有特征和行为的抽取和封装
                    接口---》是一套规范和标准的集合
    ③语法不同：抽象类中既可以有普通属性，普通方法，抽象方法；
                接口中只能有全局静态常量，共有抽象方法。
