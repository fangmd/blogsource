---
title: java -- day12
date: 2015-12-28 21:18:12
tags: [java,day]
categories: java基础

---


# Day 12
## 集合的概念以及集合框架介绍	
### 集合的概念	
>存储引用数据对象的变长的容器。

特点：

1. 存储的数据是引用类型；
2. 长度可变；
### 集合的框架结构介绍
Collection接口

1. list接口
	1. ArrayList类：
	2. LinkedList类
	3. Vector类
	4. Strck类:继承Vector，栈结构
	
    		常用方法：
     		E peek() 查看堆栈顶部的对象，但不从堆栈中移除它。 
     		E pop()  移除堆栈顶部的对象，并作为此函数的值返回该对象。 
     		E push(E item) 把项压入堆栈顶部。 
     		int search(Object o) 返回对象在堆栈中的位置，以 1 为基数。


list中特有的方法：

    E get(int index) ：根据索引值取出元素
    int indexOf(Object o) ：返回一个元素在集合中的索引值
    ListIterator<E> listIterator()  ：返回一个列表迭代器对象
    E set(int index, E element) ：使用指定的元素替换集合中相应位置的元素
    List<E> subList(int fromIndex, int toIndex)：返回指定区间的子集合，子集合中不存在结束索引对应的元素		
2. set接口	
	1. HashSet类
	2. LinkedHashSet
	3. TreeSet
### 集合与数组的对比	
1. 存储的元素不同：数值存储的是基本数据类型或者引用类型，而集合只能存储引用类型；
2. 长度是否可变；
## Collection接口	
>语法：Collection 对象名 = new Collection 接口实现类的构造方法；
### 集合对象的创建	
### Collection中常用的方法	
	
## 泛型的使用	
### 泛型应用在集合上	
### 泛型应用在类上	
### 泛型应用在方法上	

泛型：泛指的类型，指的是：将类型可以当成参数，在子类和父类，实现类和接口之间进行传递。
泛型的本质：类型的传递。

泛型的分类：
①泛型接口
语法：访问权限修饰符 interface 接口名<类型1,类型2,...,类型n>{
      }

注意：1、此处，类型1等等与接口之间不存在实现的关系，关系仅限于：
      将明示出来的类型当成一个普通的类型，在整个接口体中可以使用。
      2、泛型参数的名字是合法的java标识符
      3、至于泛型到底指的是何种具体类型，由调用处来决定，来传入具体的类型。

②泛型类
语法：访问权限修饰符 class 类名<类型1,类型2,...,类型n>{
      }

注意：1、此处，类型1等等与类之间不存在继承关系，关系仅限于：
      将明示出来的类型当成一个普通的类型，在整个类体中都可以使用。
      2、泛型参数的名字是合法的java标识符
      3、至于泛型到底指的是何种具体类型，由调用处来决定，来传入具体的类型。


③泛型方法

语法：访问权限修饰符 <类型1,类型2,...,类型n> 返回值类型 方法名(..){
      }

注意：1、此处，类型1等等与方法的关系是：
      将明示出来的类型当成一个普通的类型，在整个方法体中以及方法的声明部分都可以使用。
      2、泛型参数的名字是合法的java标识符
      3、至于泛型到底指的是何种具体类型，由调用处来决定，来传入具体的类型。

泛型语法设计的目的：
  ①最大限度提高代码的复用性。
  ②将运行时的异常提前到编译时。

需求：通过一个集合，存储班级学生的分数，求总成绩。


## Iterator迭代器	
### 迭代器的工作原理	
### 迭代器的使用	
作用：遍历集合；

集合中有一个方法的返回值是Iterator，赋值给Iterator对象，然后用Iterator的方法来处理集合；
## List接口	
### List接口的存储特点	
1. 可重复；
2. 有序；
### List接口的实现类	
1. ArrayList：底层的数据结构是数值，查询和修改元素的效率高，增删元素的效率低。	
2. LinkedList：底层的数据结构是“双向链表”（可以从链表的两头对数据进行处理，里面的每个节点不仅保存了数据也保存的该节点前后对象的地址），查询、修改的效率低，增删的效率高；
3. ArrayList与LinkedList存储的比较	

特有的方法：

1. void addFirst(E e) ：将参数指定的元素添加到集合的开始位置
2. void addLast(E e) ：将参数指定的元素添加到集合的最后的位置
3. Iterator<E> descendingIterator()：将集合中的元素反转存入迭代器
4. E getFirst() ：取出集合中第一个元素           
5. E getLast() ：取出集合中最后一个元素  
6. E pop()：取出集合中的元素（栈顶）
void push(E e) ：将参数指定的元素入栈
## Set集合的存储特点	
1. 不能重复
2. 无序
### HashSet的实现原理
1. 底层数据结构是哈希表
2. 无序（存储的顺序和输入顺序无关，但是在数据存储的时候按照底层算法实现）	
#### 重写equals()	
#### 重写equals()	
### TreeSet的实现原理	
#### Comparable接口的使用	
#### Comparator接口的使用	
### LinkedHashSet 继承hashSet，没有特别的方法
1. 底层是链表
2. 有序：元素的顺序和添加顺序一样

**遍历List集**合时，可以使用四种：

1. 迭代器
2. 增强for ---》只能取出集合中的元素，不能修改。
3. 普通for --->可以取出集合中的元素，同时还可以修改
4. 转换为数组

### TreeSet
TreeSet实现类的特点：
①排序的 （集合中的元素根据指定的顺序进行升序排列后，存入集合）
②无序的 （元素添加的顺序与底层存储的顺序不一致，特例：添加时是排好序的）
③底层存储元素时采用的数据结构是二叉树


深度挖掘TreeSet集合：
存储在该种集合中的元素为什么能够排序呢？
就对象本质而言，不具备可比性。但是，程序是用来描述现实世界，需求要求对象
能进行比较。所以，必须人为给定一个比较规则。

如何给定规则：
方式①：让需要进行比较的实例所对应的类实现Comparable接口，实现其中的copareTo（）方法，在该方法中指定比较规则。（让实例具备可比性）
    compareToz（xxx）方法，有三个返回值：0  --》当前对象与参数指定的对象相等
                                        >0 --> 当前对象大于参数指定的对象
                                        <0 --》当前对象小于参数指定的对象

方式②：构建TreeSet集合对象时，传入一个比较器对象，让容器具备可比性。
   比较器： 设计一个类，让该类实现Comparator接口,实现接口中的compare方法，在该方法中定制比较规则。



需求：定义一个TreeSet的集合，存储班级学生的信息，根据学生的年龄来排序，若年龄相同，根据身高来排序，若身高相同，根据体重来排序，若
      体重也相同，根据名字来排序。
      
思路：①设计一个Student实例类
      ②测试类，main--》构建容器对象，存储学生实例，遍历，观察结果
    


注意：
1、TreeSet集合中的元素要进行比较，有两种实现方式，在真实项目中选择其一即可，不要“双管齐下”。
   效果：对象的比较会优先选择Comparable方式；那么，Comparator方式就成了冗余的代码。

2、向一个TreeSet集合中的存入元素，元素一般要具备可比性，否则抛出ClassCastException。除非：是让容器具备可比性（Comprator方式）。



--》拓展：一般TreeSet中存放的是同一个类的对象，让同类对象之间进行比较，然后排序。但是，现实需求是变动的，让不同种类的对象进行比较，
         现实中也有很多。如何实现呢？
需求：让人、老虎、狮子赛跑，看那个物种速度快，速度升序，若速度一样，根据体重来比较，体重降序。

分析：
1）设计三个实体类：人，老虎，狮子，且类要实现Comparable接口。
2）测试类 main：构建不同物种的对象，存入集合，打印，观察结果。
