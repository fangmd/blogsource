---
title: temp
date: 2016-08-07 13:18:12
tags: [ReadNote]
category: 读书笔记

---


# 第七章 链接


链接（linking）将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可 被加载 到存储器并执行。

链接由 链接器 程序自动执行。

链接器：在软件开发中扮演着关键角色，它使得 分离编译（separate compilation）成为可能。我们不用将一个大型的应用程序组织成为一个大的源文件。



## 编译器驱动程序


两个 c 文件:

```c
// main.c
void swap();

int buf[2] = {1, 2};

int main()
{
    swap();
    return 0;
}
```

```c
//swap.c

int *bufp0 = &buf[0];
int *bufp1;

void swap()
{
    int temp;

    bufp1 = &buf[1];
    temp = *bufp0;
    *bufp0 = *bufp1;
    *bufp1 = temp;
}
```

大多数编译系统提供 编译驱动程序（compiler diver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。

编译上面两个文件：

```
gcc -02 -g -o p main.c swap.c
```

![链接器工作图.](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/%E9%93%BE%E6%8E%A5%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%9B%BE.jpg)

## 静态链接

## 目标文件

目标文件三种形式

1. 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
2. 可执行目标文件。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。
3. 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载到存储器并链接。

## 可重定位目标文件

## 符号和符号表


## 符号解析


### 链接器如何解析多重定义的全局符号

### 与静态库链接

所有的编译系统都提供一种机制，将所有相关的目标木块打包成为一个单独的文件，称为 静态库（static library）

### 链接器如何使用静态库来解析引用

## 重定位

### 重定位条目

### 重定位符号引用


## 可执行目标文件


![可执行目标文件格式](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/可执行目标文件格式.jpg)


## 加载可执行目标文件

运行一个名为 p 的可执行目标文件

```
./p
```

通过某个驻留在存储器中称为 加载器（loader）的操作系统代码来运行它。

## 动态链接共享库


静态库需要定期维护和更新。

如果程序员想要使用一个库的最新版本，就必须通过某种方式了解该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。

共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。

共享库可以被加载到任意的存储器地址，并和一个存储器中的程序链接起来，这个过程称为 动态链接（dynamic linking），通过一个 动态链接器（dynamic linker）的程序完成。

共享库也称为共享目标，Unix系统中通常用 .so 作为后缀，windows中是 dll（动态链接库）

![共享库动态链接过程](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/共享库动态链接过程.jpg)

## 从应用程序中加载和链接共享库


## 与位置无关的代码 （PIC）

共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码，解决存储器资源。

通过 位置无关的代码 实现共享库能够被多个程序使用。

## 处理目标文件的工具


# 第八章 异常控制流

ECF：异常控制流 Exception Control Flow


## 异常

异常是异常控制流的一种形式。

异常 就是控制流中的突变，用来响应处理器状态中的某种变化。


### 异常处理

系统中每种可能的异常类型都会分配一个唯一的非负整数的 异常号（exception number）.



### 异常的类别

1. 中断 interrupt
2. 陷阱 trap
3. 故障 fault
4. 终止 abort


## 进程


异常是允许操作系统中提供 进程 概念所需要的基本构造块。

进程经典定义：一个执行中的程序的实例。

进程提供给应用程序的关键抽象：

1. 一个独立的 逻辑控制流，好像程序独占使用处理器
2. 一个私有的地址空间，好像程序独占存储器系统

### 逻辑控制流

![进程逻辑控制流](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/进程逻辑控制流.jpg)

### 并发流

一个逻辑流的执行在时机上与另一个流重叠，称为 并发流（concurrent flow）

并发（concurrency）：多个流并发执行

多任务（multitasking）：一个进程和其他进程轮流执行

时间片（time slice）：一个进程执行它的控制流的一部分的每一时间段

### 私有地址空间

### 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

处理器通过某个控制寄存器中的一个 模式位（mode bit）来实现。

设置了 模式位，进程就运行在 内核模式（超级用户模式）。这个运行在内核模式中的进程可以执行指令集中的任何指令。

用户模式：没有设置模式位。不允许执行特权指令。

### 上下文切换

内核为每个进程维持一个上下文。


## 系统调用错误处理

## 进程控制

Unix 中提供了大量从 c 程序中操作进程的系统调用。

### 获取进程 ID

pid

### 创建和终止进程

### 回收子进程

### 让进程休眠

### 加载并运行程序

## 信号

Unix 信号，允许进程中断其他进程


## 非本地跳转

## 操作进程的工具

```
strace

ps

top

pmap
```

# 第九章 虚拟存储器

虚拟存储器提供三种重要的能力：

1. 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效使用主存。
2. 为每个进程提供一致的地址空间，简化了存储器管理
3. 保护每个进程的地址空间不被其他进程破坏


## 物理和虚拟寻址

![物理寻址](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/物理寻址.png)


![虚拟寻址](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/虚拟寻址.png)


CPU芯片上叫做 存储管理单元（Memory Management Unit MMU）来讲虚拟地址转换成物理地址。

## 地址空间

地址空间：是一个非负整数地址的有序集合：{0,1,2,...}

线性地址空间：地址空间中的整数是连续的。


## 虚拟存储器作为缓存工具

## 虚拟存储器作为存储管理的工具

## 虚拟存储器作为存储器保护的工具

## 地址翻译


## 存储器映射

存储器映射：将一个存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容。

虚拟存储器区域可以映射到两种类型的对象中：

1. Unix 文件系统中的普通文件
2. 匿名文件

### 再看共享对象

进程这个抽象能够为每个进程提供一个私有的虚拟地址空间，免受其他进程的错误读写。

存储器映射提供了一种控制多个进程如何共享对象的方案。

一个对象可以被映射到虚拟存储器的一个区域，要么作为 **共享对象**，要么作为 **私有对象**

作为 共享对象：映射到虚拟存储器的区域称为 共享区域，进程对这个区域作出的任何写操作对于其他进程是可见的而且会改变磁盘上的原始对象。

如果作为 私有对象：进程对这个区域作出的改变，对于其他进程是不可见的，而且进程对这个区域作出的任何写操作都不会被反映到磁盘上的对象中。私有对象 映射到虚拟存储器中的区域称为 私有区域。


![共享对象](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/共享对象.png)


![私有对象](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/私有对象.png)



### 再看 fork 函数

fork 函数 创建一个带有自己独立虚拟地址空间的新进程过程：

当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。

### 再看 execve 函数


## 动态存储器分配

动态存储器分配和维护着一个进程的虚拟存储器区域：堆 heap


### malloc 和 free 函数

### 为什么要使用动态存储器分配

在程序实际运行的时候，才知道某个数据结构的大小。

。。。。

## 垃圾收集

垃圾收集器 garbage collector 是一种动态存储分配器。它会自动释放程序不再需要的已分配块。

Mark&Sweep 标记&清除算法

### 垃圾收集器的基本知识


垃圾收集器将存储器视为一张有向 可达图（reachability graph）图的节点被 分成一组根节点和一组 堆节点

![可达图](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/可达图.png)


java 这样的语言对应用如何创建和使用指针由严格的控制，所以可以绘制出精确的可达图，能够回收所有垃圾。

但是 c，c++ 这样的语言不能绘制出精确的可达图，所以不能做到回收所有垃圾。

### Mark&Sweep 垃圾收集器

垃圾收集器由 标记 和 清除 两个阶段组成。

## c 程序中常见的与存储器有关的错误

## 小结


# 第十章 系统级 I/O

## Unix I/O

打开文件

改变当前文件位置

读写文件

关闭文件

## 打开和关闭文件

## 读和写文件

## 用 RIO 包健壮地读写

## 读取文件元数据

## 共享文件

## I/O 重定向

# 第十一章 网络编程

## 客户端-服务器编程模型

客户端向服务器端发起请求，服务器端处理请求，返回数据。

## 网络

## 全球 IP 英特网

## Web 服务器


# 第十二章 并发编程


现代操作系统提供三种基本的构造并发程序的方法：

1. 进程。进程间通信（interprocess communication IPC）
2. I/O 多路复用
3. 线程


## 基于进程的并发编程

### 基于进程的并发服务器

1. 需要一个 SIGCHLD 处理进程来回收处理 僵死子进程。
2. 父进程必须关闭各自的 connfd


### 关于进程的优劣 

进程控制 和 IPC 的开销很高 

## 基于 I/O 多路复用的并发编程

## 基于线程的并发编程


### 线程执行模型

### Posix 线程

### 创建线程

### 终止线程


## 多线程程序中的共享变量

。。。。








