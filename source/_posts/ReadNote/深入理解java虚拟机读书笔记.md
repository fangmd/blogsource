---
title: 深入理解java虚拟机
date: 2016-01-01 21:38:14
tags: android
categories: 读书笔记

---


# 《深入理解java虚拟机》读书笔记
## 第一章
### 概述
java的优点；认清java运行的本质；
### Java技术体系
Sun官方定义的Java技术体系包括了：

- Java程序设计语言
- 各种硬件平台上的Java虚拟机
- Class文件格式
- Java API类库
- 来自商业机构和开源社区的第三方类库

<!--more-->

**JDK**包括了：Java程序设计语言、Java虚拟机、Java API 类库

**JRE**包括了：Java API类库中的Java SE API子集和Java虚拟机

**Java 技术体系**

- Java Card：支持一些Java小程序(Applets)运行在小内存设备上的平台
- Java ME：移动终端的平台
- Java SE：桌面级应用
- Java EE：支持使用多层架构的企业应用的Java平台

### Java发展史
### 展望Java技术的未来

- 模块化：
- 混合语言：一个项目不同层次用不同的语言开发
- 多核并行：关注并行编程的领域，JDK1.5中加入java.util.concurrent包实现了粗粒度的并发架构
- 进一步丰富语法：JDK1.5中加入了：**自动装箱**、**泛型**、**动态注解**、**枚举**、**可变长参数**、**遍历循环**等语法特征。
- 64位虚拟机
### 实战：自己编译JDK

### 自动内存管理机制
## 第二章 Java内存区域与内存溢出异常
### 概述
Java程序的内存控制由虚拟机执行，不容易出现内存泄露和内存溢出问题，但一旦出现该问题，就很难排查。
C++内存分配管理由程序员管理。
### 运行时数据区域
Java虚拟机执行Java程序过程中会把它所管理的内存划分为若干不同的数据区域：
- 方法区：
- 虚拟机栈：
- 本地方法栈
- 堆：
- 程序计数器
#### 程序计数器
>是一块较小的内存空间。

**作用：**可以看做是当前线程所执行的字节码文件的行号指示器。**字节码解释器**工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能就是靠这个计数器实现的。
**多线程**切换也是通过计数器来恢复执行，个线程之间的计数器互补影响，独立存储，**线程私有内存**
### Java虚拟机栈Java Virtual Machine Stacks
**线程私有**，生命周期与线程相同。

虚拟机栈描述Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame）用于存储**局部变量表**（大多数人称的栈）、**操作栈**、**动态链接**、**方法出口**等信息

方法被调用直到执行完成的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。

**局部变量表**存放编译期可知的各种**基本数据类型**、**对象引用**、returnAddress类型**。

**局部变量表**所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间时完全确定的，在方法运行期间不会改变局部变量表的大小。

>注：64位长度的`long`和`double`类型站2个局部变量空间（Slot），其余的只站一个；

本区域所有的**异常**：

- `StackOverflowError`：线程请求的栈深度大于虚拟机所允许的深度。
- `OutOfMemoryError`：虚拟机栈动态扩展时无法申请到足够的内存。

#### 本地方法栈 Native Method Stacks
	与虚拟机栈所发挥的作用相似，不过是为虚拟机使用到的Native方法服务。有的虚拟机把本地方法栈和虚拟机栈合二为一，有两个异常。

#### Java堆 Java Heap
>是Java虚拟机所管理的内存中最大的一块。

Java堆是被所有**线程共享**的一块内存区域，在虚拟机启动时创建。

**作用：**存放对象实例。所有的对象实例以及数组都要在堆上分配，但随着JIT编译期的发展与逃逸分析技术的逐渐成熟，，栈上的分配、标量替换优化技术将会导致一些微妙的变化发送，所有对象都分配在堆上也渐渐变得不是那么绝对了。

Java堆是**垃圾收集器**管理的主要区域（GC堆Garbage Collected Heap）。

**OutOfMemoryError**异常：堆中没有内存完成实例分配，并且堆也无法再扩展时。
#### 方法区 Method Area
**线程共享**的内存区域

**作用：**存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。

Java虚拟机规范对这个区域的限制非常宽松，除了和堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。
OutOfMemoryError
#### 运行时常量池
>方法区的一部分。
>用于存放编译期生成的各种字面量和符号引用。
>OutOfMemoryError
#### 直接内存 Direct Memory
>不是虚拟机运行时数据区的一部分，但可能导致OutOfMemoryError

### 对象访问
`Object obj = new Object();`

`Object obj`：反映到Java栈的本地变量表中，作为一个reference类型数据出现。

`new Object()`：反映到Java堆中，形成一块储存Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，这块内存长度不固定。另外，Java堆中还必须包含能查找到此类数据（如对象类型、父类、实现的接口、方法等）的地址信息，这类数据存储在方法区中。

Java堆中访问对象的方法：

- 通过句柄访问对象：Java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据的具体地址。![](http://i.imgur.com/42vUHjU.png)
- 直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。![](http://i.imgur.com/yOpNzLV.png)
### 实战：OOM（OutOfMeremoryError）异常
## 第三章 垃圾手机器与内存分配策略
### 概述
GC需要完成的三件事：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

		**小归纳：**程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随方法的进入和退出而有条不紊地执行出栈和入栈操作。
## 对象已死？
### 引用计数算法
>**如何判断是否存活**：
>
>通常的方法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器的值就减1；任何时刻计数器都为0的对象就不可能再被使用了。（**计数算法内存管理**）但很难解决对象之间的相互循环引用的问题。
> >比如：`objA.instance = objB  objBinstance = objA`AB的计数器都不为0，但实际它们不可能被访问了。

>Java中的方法：根搜索算法

### 根搜索算法 GC Roots Tracing
**思路：**通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链（Reference Chain）**，当一个对象没有任何引用链相连，则改对象为可回收对象。

**Java中GC Roots的对象包括：**

- 虚拟机栈（栈帧中的本地变量表）中的引用对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）的引用的对象

### 再谈引用
>判断对象是否存活和**引用**有关

>**JDK1.2**前引用的定义：如果reference 类型的数据中存储的数值代表的式另一块内存的起始地址，就称这块内存代表着一块引用。（不够有用）

>**JDK1.2后**引用定义扩充：
> 
> - 强引用（Stong Reference）：`Object obj = new Object()`
> - 软引用（Soft Reference）：SoftReference类来实现，系统将发生内存溢出前，会把这类对象列进回收范围中并进行第二次回收。如果还是没有足够的内存才会报内存溢出异常。
> - 弱应用（Weak Reference）：这类对象只能生存到下一次垃圾收集发生前。（无论内存是否足够都会被回收）
> - 虚引用（Phantom Reference）：唯一作用：这个对象被回收时受到一个系统通知。PhantomReference

### 生存还是死亡？
`finalize()`方法，不建议使用。可以自救一次。
### 回收方法区
>Java虚拟机规范中并不要求虚拟机在方法区实现垃圾收集，因为在方法区进行垃圾收集的性价比很低。

永久代的垃圾收集主要回收两部分内容：

- 废弃常量
- 无用的类：3个条件：
	- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
	- 加载该类的ClassLoader已经被回收。
	- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法再任何地方用过反射访问该类的方法。

## 垃圾收集算法
### 标记 - 清除算法
算法分**标记**和**清除**两个阶段：

1. 标记所有需要回收的对象
2. 标记完成后统一回收标记的对象

该算法的**缺点**：

1. 效率低
2. 空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多会导致当程序需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一层垃圾收集动作。
![](http://i.imgur.com/W4siylj.png)
### 复制算法 Copying
>**提高效率**
>将内存分为两大块：一块实时使用，内存回收后将这块的内存内容复制到另一块内存中储存。

>**缺点**将内存缩小为原来的一半
>
>(IB<公司研究：内存空间划分不用1:1而是保存区小，实时运行区大)
![](http://i.imgur.com/UrkPbho.png)
### 标记 - 整理算法
>复制收集算法在对象存活率较高时要执行较多的复制操作，效率低，而且要浪费一半的内存空间。

>标记整理算法和标记清除算法类似：不过在清理前需要将标记的对象都移到内存的一端![](http://i.imgur.com/wznLK4p.png)

### 分代收集算法
**商业虚拟机**的垃圾收集都采用“分代收集”算法。
**特点：**把Java堆分为新生代和老年代

1. 新生代：每次有大批的对象死去，使用**复制算法**
2. 老年代：对象存活率高，使用**标记 - 清理**、**标记 - 整理**
## 垃圾收集器
>收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

Java虚拟中堆垃圾收集器没有作任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器可能有很大差别。![](http://i.imgur.com/TC1FIKk.png)
### Serial收集器
Serial收集器是最基本、历史最悠久的收集器，**单线程**收集器，在使用时必须停止所有的工作现场（Sun称这为`Stop the world`）![](http://i.imgur.com/7xH3eRt.png)

**优点：**简单高效。

### ParNew收集器
>新生代收集器
>
>就是Serial收集器的多线程版本，其他的原理与Serial一样。
![](http://i.imgur.com/7Mdq7FS.png)
### Parallel Scanvenge收集器
>新生代收集器，使用**复制算法**、**多线程**

**特点：**CMS等收集器关注的在于尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的**吞吐量（ThroughPut）**。`吞吐量 = 运行代码时间/（运行代码时间 + 垃圾收集时间）`吞吐量越短越适合用户交互程序，良好的响应速度能提升用户的体验。

Parallel Scavenge收集器提供两个参数精确控制吞吐量：

1. `-XX:MaxGCPauseMillis`最大垃圾收集停顿时间参数
2. `-XX：GCTimeRatio`设置吞吐量大小的参数

### Serial Old 收集器
### Parallel Old 收集器
### CMS 收集器
### G1收集器
### 垃圾收集器参数总结

## 内存分配与回收策略
自动内存管理：

1. 给对象分配内存
2. 回收分配给对象的内存

### 对象优先在Eden分配
### 大对象直接进入老年代
**大对象：**需要大量连续内存空间的Java对象。如：很长的字符串，数组，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。

虚拟机中提供了一个：`-XX：PretenureSizeThreshold`参数，把大于这个值的对象直接分配到老年代中。**目的**避免在Eden区和两个Survivor区之间发生大量的内存拷贝（复习：新生代采用复制算法收集内存）
### 长期存活的对象将进入老年代
### 动态对象年龄判定
**进入老年代要求**

- 达到MaxTenuringThreshold
- 在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象。

### 空间分配担保

## 第四章 虚拟机性能监控与故障处理工具
## 第五章 调优案例分析与实战
### 第六章 类文件结构
## 概述
Native Code ,代码编译的结果从本地机器码转变为字节码。
## 无关性的基石
Java宣传口号**一次编写，到处运行Write Once， Run Anywhere**

实现**语言无关性**的基础：虚拟机和字节码存储格式，其他语言的程序代码也可以编译成Class文件，Class文件在虚拟机中运行。
## Class类文件的结构
解析Class文件的数据结构。

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在Class文件中，中间没有添加任何分隔符。当遇到需要占用8位以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

Class文件：伪结构，由两种数据类型构成：**无符号数**、**表**

- 无符号数：u1、u2、u4、u8来分别代表相应字节数的无符号数，可以描述：数字、索引引用、数量值，或者按照UTF-8编码构成字符串值。
- 表：由多个无符号数或其他表作为数据项构成的复合数据类型，所有表都以`_info`结尾。 表用于描述有层次关系的复合结构的数据，Class文件本质就是一张表。
### 魔数与Class文件的版本
**魔数：**每个Class文件的头4个字节。**作用：**确定这个文件是否是能被虚拟机接受的Class文件。（因为扩展名很容易被改变）Class魔数：`0xCAFEBABE`，魔术后面的4个字节储存的是Class的主版本号**Major Version**JDK1.7对应的版本号为：51.0
***************

### 常量池
版本号之后是常量池入口，常量池是Class文件结构中与其他项目关联最多的数据类型，也是占用Class**文件空间最大**的数据项目之一，同时也是Class文件中**第一个出现的表类型数据项目**。

常量池中的常量不固定，所以在入口处需要一个u2类型，代表常量池容量计数值（**constant_pool_count**）。注：这个计数从1开始。第项常量空出来表示：不引用任何一个常量池项目。
**常量池：**

- 字面量（Literal）：如文本字符串、被声明为final的常量值。
- 符号引用（Symbolic References）：类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。
![](http://i.imgur.com/M7QPczJ.png)
**常量池是最繁琐的数据：**11中常量类型各自均有自己的结构，![](http://i.imgur.com/CACfgqV.png)
**tag**：标志位；**name_index**索引值，指向常量池中的一个`CONSTANT_Utf8_info`类型的常量（类或者接口的全限定名）![](http://i.imgur.com/N6gUeZF.png)
**length值**UTF-8编码的字符串长度的字节数，
![](http://i.imgur.com/f5SNYsw.png)


### 访问标志
### 类索引、父类索引与接口索引集合
### 字段表集合
### 方法表集合
### 属性表集合
## Class文件结构的发展



















