---
title: Java head first
date: 2016-03-25 21:18:12
tags: java基础
category: 读书笔记

---

## primitive 主数据类型和引用 
### P54 引用变量
- 不存在对象变量
- 引用(reference)到对象的变量
- 对象的引用变量保存的是存取对象的方法
- 引用变量中实际装载的是对象的地址，java虚拟机知道如何通过引用来获取对象

主数据类型变量值：是该值的字节所表示的；

引用变量的值是代表位于堆之对象的存取方法。
### P59 数组也是对象
>Java注重类型，一旦数组被声明出来，就只能装入所声明类型的元素。

没有primitive主数据类型的数组，只有装载primitive主数据类型的数组；

实参：argument；形参：paramenter；

<!--more-->

### P77 Java值传递
>Java是通过值传递的也就是说用过拷贝传递。

可解释java中方法对变量的改变且不返回时，变量不改变的事实。
### P85 实例变量与局部变量的区别
1. 实例变量声明在类内而不是方法中
2. 局部变量声明在方法中
3. 局部变量在使用前必须初始化

>注：局部变量没有默认值，使用时需要初始化；实例变量有默认值使用时不需要初始化。

### P86 变量的比较
>使用==比较两个primitive主数据类型，或者判断两个引用是否引用同一个对象，使用equals来判断两个对象是否在意义上相等。
### P155 包
包作用：	

1. 包组织项目或函数库相对于一大堆零散的类，以功能来组织会比较好。
2. 制造出名称空间，以便错开相同名称的类。（比如好几个程序员都设计了Set类，就可以用不同的包名称来分辨）。
3.  限制同一包之间的类才能相互存取以维护安全性。

### javax由来
> 标准版的扩展包都以javax名称作为开头。
### 继承的意义
1. 避免重复的程序代码
2. 定义出共同的协议
### P184 对象声明、创建于赋值的三个步骤
1. 声明一个变量：`Dog myDog`
2. 创建对象：`new Dog();`
3. 链接对象和引用：`=`

重点在于引用类型与对象类型必须兼容。
### P188多态
> 通过多态，可以编译出引进新子类时也不必修改的程序；

三种方法防止类产生子类：

1. 存取控制：就算类不能标记为私有，但它还是可以不标记公有。非公有的类只能被同包的类做出子类；**类不能私有？**
2. 使用final修饰符
3. 类的构造器私有化

#### P190覆盖规则 子类覆盖父类方法

1. 形参(paramenter)必须一样，且返回值必须兼容
2. 不能降低方法的存取权限：存取权限必须相同或者更为开放

#### P191 方法的重载(overload)
>重载的意义是两个方法的名称相同，但参数不同，重载和多态无关。

1. 返回类型可以不同
2. 不能只改变返回类型：因为在同种参数传入时，有两个方法都符合，编译器会报错
3. 可以更改存取权限

#### P200 抽象 abstract

1. 抽象类：不会被初始化，必须要被extends过
2. 抽象方法：一定要被覆盖过，抽象方法没有方法体因为没有意义他必须被覆盖(非抽象类中不能有抽象方法)，子类必须实现所有的抽象方法。

>就算只有一个抽象的方法，这个类也必须被标记为抽象的。

抽象方法的意义：就算无法实现出方法的内容，但还是可以定义出一组子型共同的协议。**好处：**多态，子型都会有那些抽象的方法。

### P209 终极对象 Object 
需要知道的方法：

1. equals
2. hashCode
3. getClass
4. toString

![](http://i.imgur.com/svcI961.png)
### P210 总结
1. Object不是抽象类：其中的所有方法都实现程序代码，没有必要被覆盖。
2. Object对象实例化常用用途：线程的同步化。
3. Object主要目的：
	1. 作为多态：让方法可以应付多种数据类型
	2. 提供Java在执行期间对任何对象都有需要的方法的实现程序代码。
4. 为什么不把所有类定义为Object类型：类安全检查是Java保护程序代码的总要机制。而且一个类作为Object类型的实例创建的化它就只能使用Object类中的方法；`Object o = new Farrai(); o.goFast();//非法`
5. `ArrayList<Object>`把dog类放到这个集合中，去除的对象会作为Object的实例，它不能调用dog类特有的方法；`o instanceof Dog` .`Dog d = (Dog) o`可通过强转来恢复对象
6. 类的公有方法当作是合约的内容，合约是你对其他程序的承诺协议。
7. Java多继承：“致命方块”，当两个父类继承同一个父类时，子类执行父类的方法就不知道该执行两个父类中的哪一个的方法好了。

### 接口  P229
将接口取代具体的子类或抽象的父类作为参数或返回类型,则就就可以传入任何有实现该接口的东西.

要点:

1. 抽象的方法必须在具体的类中运行;
2. 不管实际上所引用的对象是什么类型,只有在引用变量的类型就是带有某方法的类型时才能调用该方法.
3. Object引用变量在没有类型转换的情况下不能赋值给其他的类型,若堆上的对象类型与所要转换的类型不兼容,则此转换会在执行期间异常. 因为编译发现不了所以instanceof 很重要
4. 从`ArrayList<Object>`中取出的对象只能被`Object`引用,不然就要用类型转换来改变.
5. 接口就像是100%纯天然的抽象类
6. 实现某接口的类必须实现它所有的方法,因为接口中的方法都是public abstract的
7. `super.方法`在子类中调用父类的方法.

### 构造器与垃圾收集器GC
堆 heap : 对象生存 

栈 stack : 方法调用及变量的生存空间(局部变量)  

注:实例变量是被声明在类中的而不是方法中,所以实例变量存在与所属的对象中;**局部变量和方法的参数**都是被声明在方法中,他们是暂时的,生命周期只限于方法被放在栈上的这段时间(也就是方法调用至执行完毕)

为什么要知道堆栈的机制:了解变量的有效范围(scope),对象的建立,内存管理,线程(thread)和异常处理.

构造方法没有返回值类型:**void**也没有

构造方法的妙用:在构造方法内可以作很多事情:

1. 记录构造对象的数量
2. 记录特定的状态
3. 给实力变量赋值
4. 留下创建对象的证据
5. 将对象加到ArrayList中**如何实现?**
6. 创建HAS-A对象

构造函数和普通方法的主要区别: java中可以有与类名相同的方法而不会变成构造函数,主要差别是是否有返回类型.

要点:

1. 实力变量保存在所属的对象中,位于堆上.
2. 如果实力变量是一个对象的引用,则引用与对象都在堆上
3. 构造函数是一个会在新建对象时执行的代码快,这里可以会对象作很多操作
4. 构造函数必须和类名相同且没有返回值类型.
5. 当使用五参构造方法的时候可以在代码块中堆属性赋值,默认值 

编译器涉入构造函数的两种方式:

1. 当没有编写构造函数的时候
2. 如果构造函数中没有调用`super()`;

### P260 三种方法释放对象
1. 引用永久性的离开它的范围(引用定义在局部)
2. 引用被赋值到其他的对象上
3. 直接将引用设定为`null`

### P275 静态方法
>在java中使用工具类的方法时，不需要工具类对象，因为工具类中的方法是静态的属于类。

1. 用类名调用静态方法
2. 用引用调用非静态方法
3. 工具类一般不希望实例化，所以一般会定义一个私有的构造方法
4. 静态方法不能调用非静态属性和方法。

### P281 静态变量
>静态变量有默认初始值，（可以不赋值）。
>一般静态代码块的作用是给静态属性赋值


### P283 final修饰的方法
1. 可以被继承，不能被重写。
2. 在本类中可以被重载。

### P284 静态
1. 如果类中只有静态方法，可以将构造函数标记为private的以避免被初始化。
2. 在java中的常量是把变量同时标记为static和final的。
3. `fanal`的静态变量必须在声明或静态初始化程序（静态代码块）中赋值。

### autoboxing的用处
1. 方法的参数： 参数定义成基本类型也可以传入包装对象，反之同理。
2. 返回值
3. boolean 表达式： 例子：在if中的是包装类或者是基本数据类型
4. 数值运算
5. 赋值

### P293 将基本数据类型转换成String
1. `String str = ""+d(基本数据类型)`,加号是唯一一个重载过的运算符。
2. `String str = Double.toString(d);`用包装类的静态方法

### P298 格式化数值
%[argument number][flags][width][.precision]type

1. 如果要格式化的参数超过一个以上，可以在这里指定是哪一个
2. 特定类型的特定选项如数值要加逗号或正负号
3. 最小的符号数，注意：这不是总数，输出可以超过此宽度若不足则会自动补全
4. 精确度，注意前面有个原点符号
5. 一定要指定的类型标识 （唯一的必填项）

### P301 String.format 日期

### Date and Calendar
>获取当前日期用Date其余的操作使用Calendar

Calendar是一个抽象类
1. 通过一个静态方法获取实例：`Calendar cal = Calendar.getInstance();`

注意：
1. 字段会保存状态
2. 日期和时间可以运算
3. 日期和时间可以用millisecond来表示

![](http://i.imgur.com/IhB85Xh.png)

### P320异常
1. 如果有抛出异常，则一定要使用throw来声明这件事；
2. 编译器不会注意RuntimeException类型的异常，他不需要被声明或者包爱try/catch中（不过这一这样做）
3. 编译器关心的是检查时异常，程序必须要认识的有异常可能的存在
4. 如果不打算处理异常，也可以正式地将异常ducking来通过编译

try/catch/final:
1. try失败或者成功，final都会运行；
2. 如果在try或者catch中有return指令，finally还是会执行，但是不会影响return的结果

**语法：**
1. catch与finally不能没有try；
2. try一定要有catch或finally；
3. try与catch之间不能有程序；
4. 只带有finally的try必须声明异常（不处理必须在方法声明处抛异常）；

### 跳过 GUI

### P432 序列化和文件的输入/输出
