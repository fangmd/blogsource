---
title: 深入理解计算机系统
date: 2017-11-04 21:18:12
tags: [ReadNote]
category: 读书笔记

---

# 第一章 计算机系统漫游

系统在执行下面 代码 的时候发生了什么

hello.cpp

```c++
#include <iostream>
using namespace std;
 
// main() 是程序开始执行的地方
 
int main()
{
   cout << "Hello World"; // 输出 Hello World
   return 0;
}
```

## 信息就是 位 + 上下文

hello 程序生命周期从其 源文件 开始。源文件实际就是由值1/0组成的 bit 序列。8 bit 为一个字节，一个字节表示一个文本字符。

大部分现代系统都是用 ASCII 标准表示文本字符。（用一个唯一的单子节大小的整数表示每个字符）

比如: # 字符对应 35

```
#->35
i->105
...

```

hello.cpp 这样只由 ASCII 字符构成的文件称为 **文本文件**，其他文件称为 二进制文件。

## 程序被其他程序翻译成不同的格式

hello.cpp 是可以被人类读懂的文件，但是要让它在电脑中运行还需要将其转化成 机器语言指令，将这些 指令 按照 可执行目标程序 的格式打包好，以二进制磁盘文件形式存放起来。

源文件到可执行文件： 

```
g++ hello.cpp -o hello
```

## 了解编译系统如何工作是大有益处的

## 处理器读并解释存储在存储器中的指令

上面的步骤把： hello.cpp 编译成了 hello 可执行文件。

运行这个文件：在 shell 中运行这个执行文件

```
./hello
```

### 系统的硬件组成


![系统硬件组成](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png)

1. 总线：贯穿整个系统的电子管道
2. I/O 设备：每个 I/O设备 都通过 控制器或适配器 与 I/O总线 相连接.(控制器是主版上的芯片组，适配器则是主版插槽上的卡)
3. 主存：临时存储设备，由 一组动态随机存取存储器（DRAM）芯片组成的。
4. 处理器：CPU

### 运行 hello 程序

将 hello 目标文件中的代码和数据从磁盘中复制到 主存，处理器开始执行 hello 程序的 main 程序中的机器语言指令。将“hello，world” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备。

## 高速缓存至关重要

高速缓存存储器：存储 处理器 近期可能会使用到的信息。


## 存储设备形成层次结构

![存储器层次结构](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/存储器层次结构.png)

## 操作系统管理硬件

应用程序对硬件的操作必须通过操作系统。

操作系统的两个基本功能：

1. 防止硬件被失控的应用程序滥用
2. 向应用程序提供简单一致的机制来控制复杂而又大都相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程，虚拟存储器和文件）来实现这两个功能。


### 进程

进程：创造一个假象 这个系统上只有一个程序在运行。

进程：是操作系统对一个正在运行的程序的一种抽象。

一个系统可以运行多个进程，多个进程貌似并发运行，实际上 cpu 是交错运行不同进程的指令。

上下文切换：操作系统实现交错执行的机制。

上下文：进程运行所需的所有状态信息。在切换进程的时候就需要切换上下文。

### 线程

进程可以由多个线程单元组成。

### 虚拟存储器

进程虚拟地址空间：每个进程看到一致的存储器，为每个进程提供一个假象（进程在独占使用主存）


![进程虚拟地址空间](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/进程虚拟地址空间.png)


- 程序代码和数据：大小在程序运行时就确定了
- 堆：运行时堆，在代码运行时会动态扩展和收缩
- 共享库
- 栈：编译器用它来实现函数调用。大小动态
- 内核虚拟存储器：内核总是驻留在内存中

### 文件

文件就是字节序列。

## 系统之间利用网络通信

## 重要主题

### 并发和并行

并发：同时具有多个活动的系统

并行：用并发使一个系统运行更快

1. 线程级并发：在多核CPU中可以真正支持多线程同时执行， Intel Core i7 处理器可以让一个核执行两个线程，所以4核可以并行执行8个线程。
2. 指令集并行
3. 单指令、多数据并行

### 计算机系统中抽象的重要性

# 第二章 信息的表示和处理

## 信息存储

计算机中使用 一个字节 作为做小的可寻址的存储单位。

存储器的每个字节都由一个唯一数字来标示：地址

## 十六进制表示法

一个字节8位，

二进制表示范围：00000000 - 11111111

十进制表示范围：0-255

十六进制表示范围：00-FF

### 字

### 数据大小

### 寻址和字节顺序

对于跨越多字节的程序对象，通常多字节对象被存储为连续的字节序列，对象的地址为所使用的字节中最小地址。

### 表示字符串

文字编码 Unicode 标准：UTF-8,UTF-16

要求文本串中每个字符占用4个字节，常见的字符只需要1个或者2个字节

### 布尔代数

二进制的计算方式

### c语言中的位级运算

|,&,~

### c语言中的逻辑运算

||，&&，！

### c语言中的位移运算

<<,>>

## 整数表示

### 整型数据类型

### 无符号数的编码

### 补码编码

。。。。


# 第三章 程序的机器级表示


汇编代码是机器代码的文本表示，给出程序中的每一条指令。

## 历史观点

Intel 处理器系列俗称 x86

## 程序编码

### 机器级代码

机器级程序的额格式和行为：指令集体系结（Instruction set architecture ISA）

机器级程序使用的存储器地址是虚拟地址。

。。。。


汇编




# 第四章 处理器体系结构


## Y86 指令集体系结构

## 逻辑设计和硬件控制语言 HCL


。。。。



# 第五章 优化程序性能




# 第六章 存储器层次结构


# 第七章 链接


链接（linking）将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可 被加载 到存储器并执行。

链接由 链接器 程序自动执行。

链接器：在软件开发中扮演着关键角色，它使得 分离编译（separate compilation）成为可能。我们不用将一个大型的应用程序组织成为一个大的源文件。



## 编译器驱动程序


两个 c 文件:

```c
// main.c
void swap();

int buf[2] = {1, 2};

int main()
{
    swap();
    return 0;
}
```

```c
//swap.c

int *bufp0 = &buf[0];
int *bufp1;

void swap()
{
    int temp;

    bufp1 = &buf[1];
    temp = *bufp0;
    *bufp0 = *bufp1;
    *bufp1 = temp;
}
```

大多数编译系统提供 编译驱动程序（compiler diver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。

编译上面两个文件：

```
gcc -02 -g -o p main.c swap.c
```

![链接器工作图.](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/%E9%93%BE%E6%8E%A5%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%9B%BE.jpg)

## 静态链接

## 目标文件

目标文件三种形式

1. 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
2. 可执行目标文件。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。
3. 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载到存储器并链接。

## 可重定位目标文件

## 符号和符号表


## 符号解析


### 链接器如何解析多重定义的全局符号

### 与静态库链接

所有的编译系统都提供一种机制，将所有相关的目标木块打包成为一个单独的文件，称为 静态库（static library）

### 链接器如何使用静态库来解析引用

## 重定位

### 重定位条目

### 重定位符号引用


## 可执行目标文件


![可执行目标文件格式](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/可执行目标文件格式.jpg)


## 加载可执行目标文件

运行一个名为 p 的可执行目标文件

```
./p
```

通过某个驻留在存储器中称为 加载器（loader）的操作系统代码来运行它。

## 动态链接共享库


静态库需要定期维护和更新。

如果程序员想要使用一个库的最新版本，就必须通过某种方式了解该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。

共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。

共享库可以被加载到任意的存储器地址，并和一个存储器中的程序链接起来，这个过程称为 动态链接（dynamic linking），通过一个 动态链接器（dynamic linker）的程序完成。

共享库也称为共享目标，Unix系统中通常用 .so 作为后缀，windows中是 dll（动态链接库）

![共享库动态链接过程](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/共享库动态链接过程.jpg)

## 从应用程序中加载和链接共享库


## 与位置无关的代码 （PIC）

共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码，解决存储器资源。

通过 位置无关的代码 实现共享库能够被多个程序使用。

## 处理目标文件的工具


# 第八章 异常控制流

ECF：异常控制流 Exception Control Flow


## 异常

异常是异常控制流的一种形式。

异常 就是控制流中的突变，用来响应处理器状态中的某种变化。


### 异常处理

系统中每种可能的异常类型都会分配一个唯一的非负整数的 异常号（exception number）.



### 异常的类别

1. 中断 interrupt
2. 陷阱 trap
3. 故障 fault
4. 终止 abort


## 进程


异常是允许操作系统中提供 进程 概念所需要的基本构造块。

进程经典定义：一个执行中的程序的实例。

进程提供给应用程序的关键抽象：

1. 一个独立的 逻辑控制流，好像程序独占使用处理器
2. 一个私有的地址空间，好像程序独占存储器系统

### 逻辑控制流

![进程逻辑控制流](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/进程逻辑控制流.jpg)

### 并发流

一个逻辑流的执行在时机上与另一个流重叠，称为 并发流（concurrent flow）

并发（concurrency）：多个流并发执行

多任务（multitasking）：一个进程和其他进程轮流执行

时间片（time slice）：一个进程执行它的控制流的一部分的每一时间段

### 私有地址空间

### 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

处理器通过某个控制寄存器中的一个 模式位（mode bit）来实现。

设置了 模式位，进程就运行在 内核模式（超级用户模式）。这个运行在内核模式中的进程可以执行指令集中的任何指令。

用户模式：没有设置模式位。不允许执行特权指令。

### 上下文切换

内核为每个进程维持一个上下文。


## 系统调用错误处理

## 进程控制

Unix 中提供了大量从 c 程序中操作进程的系统调用。

### 获取进程 ID

pid

### 创建和终止进程

### 回收子进程

### 让进程休眠

### 加载并运行程序

## 信号

Unix 信号，允许进程中断其他进程


## 非本地跳转

## 操作进程的工具

```
strace

ps

top

pmap
```

# 第九章 虚拟存储器

虚拟存储器提供三种重要的能力：

1. 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效使用主存。
2. 为每个进程提供一致的地址空间，简化了存储器管理
3. 保护每个进程的地址空间不被其他进程破坏


## 物理和虚拟寻址

![物理寻址](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/物理寻址.png)


![虚拟寻址](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/虚拟寻址.png)


CPU芯片上叫做 存储管理单元（Memory Management Unit MMU）来讲虚拟地址转换成物理地址。

## 地址空间

地址空间：是一个非负整数地址的有序集合：{0,1,2,...}

线性地址空间：地址空间中的整数是连续的。


## 虚拟存储器作为缓存工具

## 虚拟存储器作为存储管理的工具

## 虚拟存储器作为存储器保护的工具

## 地址翻译


## 存储器映射

存储器映射：将一个存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容。

虚拟存储器区域可以映射到两种类型的对象中：

1. Unix 文件系统中的普通文件
2. 匿名文件

### 再看共享对象

进程这个抽象能够为每个进程提供一个私有的虚拟地址空间，免受其他进程的错误读写。

存储器映射提供了一种控制多个进程如何共享对象的方案。

一个对象可以被映射到虚拟存储器的一个区域，要么作为 **共享对象**，要么作为 **私有对象**

作为 共享对象：映射到虚拟存储器的区域称为 共享区域，进程对这个区域作出的任何写操作对于其他进程是可见的而且会改变磁盘上的原始对象。

如果作为 私有对象：进程对这个区域作出的改变，对于其他进程是不可见的，而且进程对这个区域作出的任何写操作都不会被反映到磁盘上的对象中。私有对象 映射到虚拟存储器中的区域称为 私有区域。


![共享对象](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/共享对象.png)


![私有对象](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/私有对象.png)



### 再看 fork 函数

fork 函数 创建一个带有自己独立虚拟地址空间的新进程过程：

当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。

### 再看 execve 函数


## 动态存储器分配

动态存储器分配和维护着一个进程的虚拟存储器区域：堆 heap


### malloc 和 free 函数

### 为什么要使用动态存储器分配

在程序实际运行的时候，才知道某个数据结构的大小。

。。。。

## 垃圾收集

垃圾收集器 garbage collector 是一种动态存储分配器。它会自动释放程序不再需要的已分配块。

Mark&Sweep 标记&清除算法

### 垃圾收集器的基本知识


垃圾收集器将存储器视为一张有向 可达图（reachability graph）图的节点被 分成一组根节点和一组 堆节点

![可达图](https://raw.githubusercontent.com/fangmd/markdownphoto/master/src/可达图.png)


java 这样的语言对应用如何创建和使用指针由严格的控制，所以可以绘制出精确的可达图，能够回收所有垃圾。

但是 c，c++ 这样的语言不能绘制出精确的可达图，所以不能做到回收所有垃圾。

### Mark&Sweep 垃圾收集器

垃圾收集器由 标记 和 清除 两个阶段组成。

## c 程序中常见的与存储器有关的错误

## 小结


# 第十章 系统级 I/O

## Unix I/O

打开文件

改变当前文件位置

读写文件

关闭文件

## 打开和关闭文件

## 读和写文件

## 用 RIO 包健壮地读写

## 读取文件元数据

## 共享文件

## I/O 重定向

# 第十一章 网络编程

## 客户端-服务器编程模型

客户端向服务器端发起请求，服务器端处理请求，返回数据。

## 网络

## 全球 IP 英特网

## Web 服务器


# 第十二章 并发编程


现代操作系统提供三种基本的构造并发程序的方法：

1. 进程。进程间通信（interprocess communication IPC）
2. I/O 多路复用
3. 线程


## 基于进程的并发编程

### 基于进程的并发服务器

1. 需要一个 SIGCHLD 处理进程来回收处理 僵死子进程。
2. 父进程必须关闭各自的 connfd


### 关于进程的优劣 

进程控制 和 IPC 的开销很高 

## 基于 I/O 多路复用的并发编程

## 基于线程的并发编程


### 线程执行模型

### Posix 线程

### 创建线程

### 终止线程


## 多线程程序中的共享变量

。。。。


